<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç®—æ³•å¯è§†åŒ– (Gemini Style)</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* --- å…¨å±€æ ·å¼ (Gemini Light Theme) --- */
        :root {
            --primary-color: #1a73e8; /* Google Blue */
            --secondary-color: #e8f0fe; /* Light Blue Bg */
            --text-color: #202124;
            --text-secondary: #5f6368;
            --border-color: #dadce0;
            --bg-color: #ffffff;
            --canvas-bg: #f8f9fa;
            
            /* ç®—æ³•é¢œè‰² */
            --c-normal: #8ab4f8;
            --c-compare: #f28b82; /* Red */
            --c-swap: #fdd663;    /* Yellow */
            --c-sorted: #81c995;  /* Green */
            --c-pivot: #c58af9;   /* Purple */
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Roboto', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
        }

        h1 {
            color: var(--primary-color);
            margin-bottom: 5px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        h1::before { content: "ğŸ“Š"; }
        .subtitle { color: var(--text-secondary); font-size: 14px; margin-bottom: 25px; }

        /* --- ä¸»å®¹å™¨ --- */
        .main-container {
            background: #fff;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            padding: 25px;
            width: 850px;
            box-sizing: border-box;
        }

        /* --- ç®—æ³•ä¿¡æ¯å¡ç‰‡ --- */
        #algo-info-card {
            background: var(--secondary-color);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            border: 1px solid #d2e3fc;
        }
        .algo-name { font-size: 20px; color: var(--primary-color); font-weight: 700; margin-bottom: 8px; }
        .algo-desc { font-size: 14px; color: var(--text-secondary); line-height: 1.5; }
        .tag {
            display: inline-block; padding: 4px 12px;
            border-radius: 20px; font-size: 12px; font-weight: 500;
            margin-top: 5px; margin-left: 5px;
        }
        .tag.stable { background: #e6f4ea; color: #137333; }
        .tag.unstable { background: #fce8e6; color: #c5221f; }
        .tag.complexity { background: #fff; color: var(--text-secondary); border: 1px solid var(--border-color); }

        /* --- ç”»å¸ƒåŒºåŸŸ --- */
        #canvas-wrapper {
            background: var(--canvas-bg);
            border-radius: 12px;
            padding: 20px;
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.05);
            margin-bottom: 15px;
        }
        canvas { display: block; width: 100%; }

        /* --- å®æ—¶è§£è¯´å­—å¹• (ç¾åŒ–ç‰ˆ) --- */
        #status-bar {
            background: #fff;
            border-left: 6px solid var(--primary-color);
            border-radius: 8px;
            padding: 15px 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            font-size: 16px;
            color: var(--text-color);
            display: flex;
            align-items: center;
            min-height: 24px;
            transition: all 0.3s;
        }
        #status-bar.paused {
            border-left-color: #fbbc04;
            background: #fff8e1;
        }
        .status-icon { margin-right: 12px; font-size: 20px; }

        /* --- æ§åˆ¶é¢æ¿ --- */
        .controls-area {
            display: grid;
            grid-template-columns: 1.2fr 1fr;
            gap: 30px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
        }

        .control-group h3 { font-size: 14px; color: var(--text-secondary); margin-bottom: 15px; font-weight: 500; }
        
        .slider-row { display: flex; justify-content: space-between; font-size: 14px; color: var(--text-color); margin-bottom: 8px; }
        input[type=range] {
            width: 100%; cursor: pointer; accent-color: var(--primary-color);
            height: 6px; background: #ddd; border-radius: 3px;
        }

        .btn-group { display: flex; flex-direction: column; gap: 15px; justify-content: flex-end; }
        
        select {
            padding: 12px; border-radius: 8px; border: 1px solid var(--border-color);
            font-size: 15px; color: var(--text-color); width: 100%; outline: none;
            background: #fff; cursor: pointer; transition: border 0.2s;
        }
        select:hover { border-color: var(--primary-color); }

        .action-buttons { display: flex; gap: 10px; }

        button {
            padding: 12px 24px; border-radius: 50px; border: none;
            font-size: 15px; font-weight: 500; cursor: pointer;
            transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 8px;
        }
        button:active { transform: scale(0.98); }
        button:disabled { opacity: 0.6; cursor: not-allowed; }

        .btn-start { background: var(--primary-color); color: white; flex: 2; box-shadow: 0 4px 12px rgba(26,115,232,0.3); }
        .btn-start:hover { background: #155db1; }
        
        .btn-pause { background: #fff; color: var(--text-color); border: 1px solid var(--border-color); flex: 1; }
        .btn-pause:hover { background: #f1f3f4; }
        .btn-pause.resume { background: #e6f4ea; color: #137333; border-color: transparent; }

        .btn-reset { background: #fff; color: var(--text-secondary); border: none; padding: 8px 12px; font-size: 14px; }
        .btn-reset:hover { color: var(--text-color); background: #f1f3f4; }

        /* --- å›¾ä¾‹ --- */
        .legend { margin-top: 20px; font-size: 13px; color: var(--text-secondary); display: flex; gap: 20px; justify-content: center; }
        .dot { width: 12px; height: 12px; display: inline-block; border-radius: 50%; margin-right: 6px; vertical-align: middle; }

    </style>
</head>
<body>

    <h1>ç®—æ³•å¯è§†åŒ–</h1>
    <div class="subtitle">æç®€è®¾è®¡ Â· æ·±åº¦è§£è¯´ Â· é€å¸§æ¼”ç¤º</div>

    <div class="main-container">
        <div id="algo-info-card">
            <div>
                <div class="algo-name" id="info-name">å†’æ³¡æ’åº</div>
                <div class="algo-desc" id="info-desc">åŠ è½½ä¸­...</div>
            </div>
            <div style="text-align: right;">
                <span class="tag complexity" id="info-time">O(nÂ²)</span>
                <br>
                <span class="tag stable" id="info-stable">ç¨³å®š</span>
            </div>
        </div>

        <div id="canvas-wrapper">
            <canvas id="mainCanvas" width="810" height="320"></canvas>
        </div>

        <div id="status-bar">
            <span class="status-icon">ğŸ’¡</span>
            <span id="status-text">å‡†å¤‡å°±ç»ªï¼Œè¯·é€‰æ‹©ç®—æ³•å¹¶ç‚¹å‡»å¼€å§‹</span>
        </div>

        <div class="controls-area">
            <div class="control-group">
                <h3>âš™ï¸ è®¾ç½®ä¸é¢„è§ˆ</h3>
                <div class="slider-group">
                    <div class="slider-row">
                        <label>æ•°æ®é‡ <span style="color:var(--primary-color)" id="val-size">15</span></label>
                        <span>æ‹–åŠ¨å®æ—¶é¢„è§ˆ</span>
                    </div>
                    <input type="range" id="range-size" min="5" max="50" value="15" oninput="handleSizeChange()">
                    
                    <div class="slider-row" style="margin-top:15px">
                        <label>æ¼”ç¤ºé€Ÿåº¦</label>
                        <span id="val-speed" style="font-weight:500; color:var(--primary-color)">æ­£å¸¸</span>
                    </div>
                    <input type="range" id="range-speed" min="0" max="100" value="50" oninput="updateSpeedLabel()">
                </div>
            </div>

            <div class="control-group btn-group">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h3>ğŸš€ æ“ä½œ</h3>
                    <button class="btn-reset" onclick="resetSystem()">â†º é‡ç½®ç”»å¸ƒ</button>
                </div>
                <select id="algo-select" onchange="updateAlgoInfo()">
                    <option value="bubble">å†’æ³¡æ’åº (Bubble Sort)</option>
                    <option value="selection">é€‰æ‹©æ’åº (Selection Sort)</option>
                    <option value="insertion">æ’å…¥æ’åº (Insertion Sort)</option>
                    <option value="quick">å¿«é€Ÿæ’åº (Quick Sort)</option>
                    <option value="merge">å½’å¹¶æ’åº (Merge Sort)</option>
                </select>
                <div class="action-buttons">
                    <button id="btn-pause" class="btn-pause" onclick="togglePause()" disabled>â¸ æš‚åœ</button>
                    <button id="btn-start" class="btn-start" onclick="startSystem()">â–¶ å¼€å§‹æ¼”ç¤º</button>
                </div>
            </div>
        </div>
    </div>

    <div class="legend">
        <span><span class="dot" style="background:var(--c-normal)"></span>æœªæ’åº</span>
        <span><span class="dot" style="background:var(--c-compare)"></span>æ¯”è¾ƒä¸­</span>
        <span><span class="dot" style="background:var(--c-swap)"></span>äº¤æ¢/ç§»åŠ¨</span>
        <span><span class="dot" style="background:var(--c-sorted)"></span>å·²å®Œæˆ</span>
        <span><span class="dot" style="background:var(--c-pivot)"></span>åŸºå‡†/è¾…åŠ©</span>
    </div>

    <script>
        // --- æ ·å¼å˜é‡æå– ---
        const styleStyle = getComputedStyle(document.body);
        const COLORS = {
            NORMAL: styleStyle.getPropertyValue('--c-normal').trim(),
            COMPARE: styleStyle.getPropertyValue('--c-compare').trim(),
            SWAP: styleStyle.getPropertyValue('--c-swap').trim(),
            SORTED: styleStyle.getPropertyValue('--c-sorted').trim(),
            PIVOT: styleStyle.getPropertyValue('--c-pivot').trim(),
            TEXT: styleStyle.getPropertyValue('--text-color').trim()
        };

        // --- é…ç½®æ•°æ® ---
        const ALGO_DATA = {
            'bubble': { name: "å†’æ³¡æ’åº", desc: "åƒæ°´åº•çš„æ°”æ³¡ä¸€æ ·ï¼Œæœ€å¤§çš„å…ƒç´ é€šè¿‡ä¸¤ä¸¤äº¤æ¢ï¼Œä¸€æ­¥æ­¥'æµ®'åˆ°æ•°ç»„æœ€å³ç«¯ã€‚", time: "O(nÂ²)", stable: true },
            'selection': { name: "é€‰æ‹©æ’åº", desc: "æ¯æ¬¡åœ¨æœªæ’åºåŒºåŸŸä¸­æ‰«æï¼Œæ‰¾å‡ºæœ€å°çš„å…ƒç´ ï¼ŒæŠŠå®ƒæ”¾åˆ°å·²æ’åºåŒºåŸŸçš„æœ«å°¾ã€‚", time: "O(nÂ²)", stable: false },
            'insertion': { name: "æ’å…¥æ’åº", desc: "æ¨¡æ‹Ÿæ•´ç†æ‰‘å…‹ç‰Œã€‚æ‹¿èµ·ä¸€å¼ æ–°ç‰Œï¼Œæ‰«æå·¦ä¾§å·²æ’å¥½çš„ç‰Œï¼Œæ’å…¥åˆ°æ­£ç¡®ä½ç½®ã€‚", time: "O(nÂ²)", stable: true },
            'quick': { name: "å¿«é€Ÿæ’åº", desc: "é€‰ä¸€ä¸ªåŸºå‡†å€¼ï¼ŒæŠŠå°äºå®ƒçš„æ”¾å·¦è¾¹ï¼Œå¤§äºå®ƒçš„æ”¾å³è¾¹ï¼Œç„¶åé€’å½’å¤„ç†ä¸¤ä¾§ã€‚", time: "O(n log n)", stable: false },
            'merge': { name: "å½’å¹¶æ’åº", desc: "åˆ†æ²»æ³•ã€‚å°†æ•°ç»„å¯¹åŠåˆ‡åˆ†ç›´åˆ°æœ€å°ï¼Œç„¶åæœ‰åºåœ°åˆå¹¶è¿™äº›å­æ•°ç»„ã€‚", time: "O(n log n)", stable: true }
        };

        // --- å…¨å±€å˜é‡ ---
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const statusText = document.getElementById('status-text');
        const statusBar = document.getElementById('status-bar');
        
        let array = [];
        let isRunning = false;
        let isPaused = false;
        let abortController = false;
        // ä¿å­˜æœ€åä¸€å¸§çš„çŠ¶æ€ï¼Œç”¨äºæš‚åœæ—¶é‡ç»˜
        let lastHighlights = {}; 

        window.onload = () => { updateAlgoInfo(); resetSystem(); updateSpeedLabel(); };

        // --- UI æ›´æ–°é€»è¾‘ ---
        function updateAlgoInfo() {
            const data = ALGO_DATA[document.getElementById('algo-select').value];
            document.getElementById('info-name').innerText = data.name;
            document.getElementById('info-desc').innerText = data.desc;
            document.getElementById('info-time').innerText = "æ—¶é—´å¤æ‚åº¦: " + data.time;
            const stableTag = document.getElementById('info-stable');
            stableTag.innerText = data.stable ? "ç¨³å®šæ’åº" : "ä¸ç¨³å®š";
            stableTag.className = "tag " + (data.stable ? "stable" : "unstable");
        }

        function handleSizeChange() {
            document.getElementById('val-size').innerText = document.getElementById('range-size').value;
            if (!isRunning) resetSystem(false);
        }

        function updateSpeedLabel() {
            const val = parseInt(document.getElementById('range-speed').value);
            let text = "";
            if(val === 0) text = "ğŸŒ é€å¸§è®²è§£ (ææ…¢)";
            else if(val < 30) text = "æ…¢åŠ¨ä½œ";
            else if(val < 70) text = "æ­£å¸¸";
            else text = "âš¡ æé€Ÿ";
            document.getElementById('val-speed').innerText = text;
        }

        function setStatus(msg, type='info') {
            // æš‚åœæ—¶ä¸æ›´æ–°æ–‡å­—ï¼Œä¿ç•™æœ€åçš„çŠ¶æ€
            if(isPaused) return;
            statusText.innerText = msg;
            statusBar.querySelector('.status-icon').innerText = type === 'success' ? 'ğŸ‰' : 'ğŸ’¡';
            statusBar.className = type === 'paused' ? 'paused' : '';
        }

        // --- æ ¸å¿ƒæ§åˆ¶ ---
        function resetSystem(forceAbort = true) {
            if (isRunning && forceAbort) {
                abortController = true; isPaused = false; updateUIState('running');
                setTimeout(() => resetSystem(false), 100); return;
            }
            abortController = false; isPaused = false; isRunning = false;
            updateUIState('idle'); setStatus("å‡†å¤‡å°±ç»ª");
            const size = parseInt(document.getElementById('range-size').value);
            array = Array.from({length: size}, () => Math.floor(Math.random() * 80) + 10);
            draw({}, false); // é‡ç½®æ—¶ä¸æ›´æ–°çŠ¶æ€æ–‡å­—
        }

        async function startSystem() {
            if (isRunning) return;
            isRunning = true; abortController = false; isPaused = false;
            updateUIState('running');
            const type = document.getElementById('algo-select').value;
            try {
                if (type === 'bubble') await bubbleSort();
                if (type === 'selection') await selectionSort();
                if (type === 'insertion') await insertionSort();
                if (type === 'quick') await quickSort(0, array.length - 1);
                if (type === 'merge') await mergeSort(0, array.length - 1);
                if (!abortController) {
                    draw({}, false);
                    setStatus("æ¼”ç¤ºå®Œæˆï¼", "success");
                    await victoryAnimation();
                }
            } catch (e) { console.log("Aborted"); }
            isRunning = false; if(!abortController) updateUIState('finished');
        }

        function togglePause() {
            if (!isRunning) return;
            isPaused = !isPaused;
            updateUIState(isPaused ? 'paused' : 'running');
            if(isPaused) {
                statusBar.className = 'paused';
                statusBar.querySelector('.status-icon').innerText = 'â¸ï¸';
                // æš‚åœæ—¶ï¼Œå¼ºåˆ¶é‡ç»˜æœ€åä¸€å¸§ï¼Œç¡®ä¿çŠ¶æ€å®šæ ¼
                draw(lastHighlights, false); 
            } else {
                statusBar.className = '';
                statusBar.querySelector('.status-icon').innerText = 'ğŸ’¡';
            }
        }

        function updateUIState(state) {
            const btnStart = document.getElementById('btn-start');
            const btnPause = document.getElementById('btn-pause');
            const select = document.getElementById('algo-select');
            const rangeSize = document.getElementById('range-size');
            
            btnStart.disabled = state !== 'idle';
            select.disabled = rangeSize.disabled = state === 'running' || state === 'paused';
            btnPause.disabled = state === 'idle' || state === 'finished';
            
            if (state === 'paused') {
                btnPause.innerHTML = "â–¶ ç»§ç»­æ¼”ç¤º";
                btnPause.classList.add('resume');
            } else {
                btnPause.innerHTML = "â¸ æš‚åœ";
                btnPause.classList.remove('resume');
            }
        }

        // --- æ ¸å¿ƒå»¶æ—¶ä¸ç»˜å›¾ ---
        async function wait() {
            while (isPaused) {
                if (abortController) return Promise.reject("Aborted");
                await new Promise(r => setTimeout(r, 50));
            }
            if (abortController) return Promise.reject("Aborted");
            
            const speed = parseInt(document.getElementById('range-speed').value);
            // é€Ÿåº¦æ˜ å°„ä¼˜åŒ–ï¼š0 -> 3000ms (ææ…¢), 100 -> 10ms (æå¿«)
            let delay = 0;
            if (speed === 0) delay = 3000; // é€å¸§æ¨¡å¼
            else delay = 1010 - (speed * 10);
            
            await new Promise(r => setTimeout(r, delay));
        }

        function draw(highlights = {}, updateStatus = true, msg = "") {
            if (updateStatus && msg) setStatus(msg);
            // ä¿å­˜å½“å‰é«˜äº®çŠ¶æ€ï¼Œä¾›æš‚åœæ—¶ä½¿ç”¨
            if (!isPaused) lastHighlights = highlights;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const len = array.length;
            // è®¡ç®—åˆé€‚çš„æŸ±å­å®½åº¦å’Œé—´è·ï¼Œä½¿å…¶å±…ä¸­
            const totalWidth = canvas.width - 40;
            const barWidth = totalWidth / len;
            const gap = len < 20 ? 6 : 2;
            const actualBarWidth = barWidth - gap;
            const startX = 20 + gap / 2;

            ctx.font = "500 14px Roboto"; ctx.textAlign = "center";

            for (let i = 0; i < len; i++) {
                const h = (array[i] / 100) * (canvas.height - 60);
                const x = startX + i * barWidth;
                const y = canvas.height - h - 30;
                
                // ç»˜åˆ¶æŸ±å­ (å¸¦åœ†è§’)
                ctx.fillStyle = highlights[i] ? highlights[i] : COLORS.NORMAL;
                roundRect(ctx, x, y, actualBarWidth, h, 4, true);

                // ç»˜åˆ¶æ•°å­—
                if (len <= 25) {
                    ctx.fillStyle = COLORS.TEXT;
                    ctx.fillText(array[i], x + actualBarWidth/2, y + h + 20);
                }
            }
        }
        // è¾…åŠ©å‡½æ•°ï¼šç”»åœ†è§’çŸ©å½¢
        function roundRect(ctx, x, y, width, height, radius, fill) {
            ctx.beginPath(); ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y); ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius); ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height); ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius); ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath(); if (fill) ctx.fill();
        }

        async function victoryAnimation() {
            for (let i = 0; i < array.length; i++) {
                if (abortController) return;
                let h = {}; for(let k=0; k<=i; k++) h[k] = COLORS.SORTED;
                draw(h, false); await new Promise(r => setTimeout(r, 30));
            }
        }

        // --- æ’åºç®—æ³•å®ç° (é€»è¾‘ä¸å˜ï¼Œæ³¨é‡Šå¾®è°ƒ) ---
        async function bubbleSort() {
            for (let i = 0; i < array.length; i++) {
                for (let j = 0; j < array.length - i - 1; j++) {
                    draw({[j]: COLORS.COMPARE, [j+1]: COLORS.COMPARE}, true, `æ¯”è¾ƒ: ${array[j]} å’Œ ${array[j+1]}ï¼Œè°å¤§è°å¾€å`);
                    await wait();
                    if (array[j] > array[j+1]) {
                        [array[j], array[j+1]] = [array[j+1], array[j]];
                        draw({[j]: COLORS.SWAP, [j+1]: COLORS.SWAP}, true, `äº¤æ¢: å› ä¸º ${array[j+1]} > ${array[j]}`);
                        await wait();
                    }
                }
                draw({[array.length-1-i]: COLORS.SORTED}, true, `ç¬¬ ${array.length-i} ä¸ªä½ç½®å·²ç¡®å®š`);
                await wait();
            }
        }
        async function selectionSort() {
            for (let i = 0; i < array.length; i++) {
                let min = i;
                draw({[i]: COLORS.PIVOT}, true, `å¼€å§‹ç¬¬ ${i+1} è½®å¯»æ‰¾æœ€å°å€¼...`);
                await wait();
                for (let j = i + 1; j < array.length; j++) {
                    draw({[i]: COLORS.PIVOT, [min]: COLORS.SWAP, [j]: COLORS.COMPARE}, true, `å½“å‰æœ€å°æ˜¯ ${array[min]}ï¼Œæ£€æŸ¥ ${array[j]}`);
                    await wait();
                    if (array[j] < array[min]) {
                        min = j;
                        draw({[i]: COLORS.PIVOT, [min]: COLORS.SWAP}, true, `å‘ç°æ›´å°å€¼: ${array[min]}`);
                        await wait();
                    }
                }
                if (min !== i) {
                    [array[i], array[min]] = [array[min], array[i]];
                    draw({[i]: COLORS.SORTED, [min]: COLORS.SWAP}, true, `å°†æœ€å°å€¼ ${array[i]} äº¤æ¢åˆ°é˜Ÿé¦–`);
                    await wait();
                }
            }
        }
        async function insertionSort() {
            draw({[0]: COLORS.SORTED}, true, "é»˜è®¤ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯æ’å¥½çš„");
            await wait();
            for (let i = 1; i < array.length; i++) {
                let key = array[i]; let j = i - 1;
                draw({[i]: COLORS.PIVOT}, true, `æ‹¿èµ·æ–°ç‰Œ ${key}ï¼Œå‡†å¤‡æ’å…¥å·¦ä¾§`);
                await wait();
                while (j >= 0 && array[j] > key) {
                    array[j + 1] = array[j];
                    draw({[j]: COLORS.SWAP, [j+1]: COLORS.SWAP}, true, `${array[j]} æ¯” ${key} å¤§ï¼Œå‘åæŒªä¸€ä½`);
                    await wait();
                    j--;
                }
                array[j + 1] = key;
                draw({[j+1]: COLORS.SORTED}, true, `${key} æ’å…¥åˆ°ä½ç½® ${j+1}`);
                await wait();
            }
        }
        async function quickSort(start, end) {
            if (start >= end) return;
            let pivotIdx = await partition(start, end);
            await quickSort(start, pivotIdx - 1);
            await quickSort(pivotIdx + 1, end);
        }
        async function partition(start, end) {
            let pivotValue = array[end]; let pivotIndex = start;
            draw({[end]: COLORS.PIVOT}, true, `é€‰å–åŸºå‡†å€¼ (Pivot): ${pivotValue}`);
            await wait();
            for (let i = start; i < end; i++) {
                draw({[end]: COLORS.PIVOT, [i]: COLORS.COMPARE, [pivotIndex]: COLORS.SWAP}, true, `æ¯”è¾ƒ ${array[i]} < ${pivotValue}?`);
                await wait();
                if (array[i] < pivotValue) {
                    [array[i], array[pivotIndex]] = [array[pivotIndex], array[i]];
                    draw({[end]: COLORS.PIVOT, [i]: COLORS.SWAP, [pivotIndex]: COLORS.SWAP}, true, "å°äºåŸºå‡†ï¼Œå½’ç±»åˆ°å·¦è¾¹åŒºåŸŸ");
                    await wait();
                    pivotIndex++;
                }
            }
            [array[pivotIndex], array[end]] = [array[end], array[pivotIndex]];
            draw({[pivotIndex]: COLORS.SORTED}, true, `åŸºå‡†å€¼ ${pivotValue} å½’ä½`);
            await wait();
            return pivotIndex;
        }
        async function mergeSort(start, end) {
            if (start >= end) return;
            const mid = Math.floor((start + end) / 2);
            await mergeSort(start, mid); await mergeSort(mid + 1, end);
            await merge(start, mid, end);
        }
        async function merge(start, mid, end) {
            let left = array.slice(start, mid + 1); let right = array.slice(mid + 1, end + 1);
            let k = start, i = 0, j = 0;
            draw({}, true, `å‡†å¤‡åˆå¹¶å·¦å³ä¸¤ä¸ªæœ‰åºåŒºé—´`); await wait();
            while (i < left.length && j < right.length) {
                let h = {[k]: COLORS.SWAP};
                if (left[i] <= right[j]) { array[k] = left[i]; i++; } else { array[k] = right[j]; j++; }
                draw(h, true, `é€‰å–è¾ƒå°å€¼ ${array[k]} å¡«å…¥`); await wait(); k++;
            }
            while (i < left.length) { array[k++] = left[i++]; draw({[k-1]:COLORS.SWAP}, true, "å¡«å…¥å·¦ä¾§å‰©ä½™å…ƒç´ "); await wait(); }
            while (j < right.length) { array[k++] = right[j++]; draw({[k-1]:COLORS.SWAP}, true, "å¡«å…¥å³ä¾§å‰©ä½™å…ƒç´ "); await wait(); }
        }
    </script>
</body>
</html>